library(writexl) # For writing Excel files
install.packages("writexl")
# Load necessary libraries
# install.packages(c("readr", "writexl", "dplyr", "ggplot2")) # Uncomment and run if you don't have them
library(readr)
library(writexl) # For writing Excel files
library(dplyr)
library(ggplot2) # For visualizing the synthetic data to ensure it looks good
# Set a seed for reproducibility
set.seed(1234)
# --- Define characteristics of 3 distinct subpopulations ---
# Subpopulation 1: Younger, Higher HGB
cluster1_n <- 1500
cluster1_hgb_mean <- 9.5
cluster1_hgb_sd <- 0.8
cluster1_age_mean <- 25
cluster1_age_sd <- 5
# Subpopulation 2: Older, Moderate HGB
cluster2_n <- 2000
cluster2_hgb_mean <- 8.0
cluster2_hgb_sd <- 1.0
cluster2_age_mean <- 60
cluster2_age_sd <- 8
# Subpopulation 3: Very Young, Moderate HGB
cluster3_n <- 500
cluster3_hgb_mean <- 8.5
cluster3_hgb_sd <- 0.6
cluster3_age_mean <- 5
cluster3_age_sd <- 2
# Subpopulation 4: Older, Lower HGB (more sparse)
cluster4_n <- 1000
cluster4_hgb_mean <- 7.0
cluster4_hgb_sd <- 0.9
cluster4_age_mean <- 75
cluster4_age_sd <- 10
# --- Generate data for each subpopulation ---
data_cluster1 <- tibble(
HGB = rnorm(cluster1_n, mean = cluster1_hgb_mean, sd = cluster1_hgb_sd),
Age = rnorm(cluster1_n, mean = cluster1_age_mean, sd = cluster1_age_sd)
)
data_cluster2 <- tibble(
HGB = rnorm(cluster2_n, mean = cluster2_hgb_mean, sd = cluster2_hgb_sd),
Age = rnorm(cluster2_n, mean = cluster2_age_mean, sd = cluster2_age_sd)
)
data_cluster3 <- tibble(
HGB = rnorm(cluster3_n, mean = cluster3_hgb_mean, sd = cluster3_hgb_sd),
Age = rnorm(cluster3_n, mean = cluster3_age_mean, sd = cluster3_age_sd)
)
data_cluster4 <- tibble(
HGB = rnorm(cluster4_n, mean = cluster4_hgb_mean, sd = cluster4_hgb_sd),
Age = rnorm(cluster4_n, mean = cluster4_age_mean, sd = cluster4_age_sd)
)
# --- Combine all data and add some noise/outliers (optional) ---
synthetic_data <- bind_rows(data_cluster1, data_cluster2, data_cluster3, data_cluster4) %>%
# Ensure realistic HGB/Age ranges (e.g., no negative HGB/Age)
mutate(
HGB = pmax(0.1, HGB), # HGB cannot be negative
Age = pmax(0, Age)    # Age cannot be negative
) %>%
# Add some random noise points (optional)
bind_rows(
tibble(
HGB = runif(50, min = 4, max = 12),
Age = runif(50, min = 0, max = 100)
)
) %>%
# Shuffle the rows so clusters are not in order
sample_frac(1)
# --- Visualize the synthetic data (optional, for your verification) ---
# This plot should show distinct "blobs" corresponding to the clusters you defined.
ggplot(synthetic_data, aes(x = Age, y = HGB)) +
geom_point(alpha = 0.6) +
labs(title = "Synthetic Data for GMM Testing",
x = "Age", y = "HGB Value") +
theme_minimal()
# --- Save the data to an Excel file ---
output_file_path <- "synthetic_gmm_test_data.xlsx"
writexl::write_xlsx(synthetic_data, path = output_file_path)
message(paste("Synthetic GMM test data saved to:", output_file_path))
message("You can now upload this Excel file to your Shiny app.")
# Optionally, you can also save it as a CSV if Excel is problematic
# write_csv(synthetic_data, path = "synthetic_gmm_test_data.csv")
# message("Synthetic GMM test data also saved to: synthetic_gmm_test_data.csv")
# ---------------------------------------------
# GMM Clustering on Synthetic Hemoglobin Data
# ---------------------------------------------
library(mclust)
library(ggplot2)
# Set seed for reproducibility
set.seed(123)
# Create synthetic 2D clinical data (age & hgb)
age <- rnorm(5000, mean = 50, sd = 15)
hgb <- c(rnorm(2500, 7, 1), rnorm(2500, 10, 0.5))
hgb <- hgb[hgb >= 3.6 & hgb <= 11.7]
age <- age[1:length(hgb)]  # match lengths
# Combine into a data frame
df <- data.frame(age = age, hgb = hgb)
# Print summary
cat("----- Data Summary -----\n")
print(summary(df))
cat("------------------------\n\n")
# Z-score normalization
df_scaled <- scale(df)
# Run GMM using mclust (VVI model, valid for 2D data)
cat("----- Running Mclust (VVI model) -----\n")
result_vvi <- tryCatch({
model <- Mclust(df_scaled, G = 2:4, modelNames = "VVI")
print(summary(model))
model
}, error = function(e) {
message("Error in Mclust (VVI model): ", e$message)
NULL
})
cat("--------------------------------------\n\n")
# Optional: visualize clusters if model ran successfully
if (!is.null(result_vvi)) {
df$cluster <- as.factor(result_vvi$classification)
ggplot(df, aes(x = age, y = hgb, color = cluster)) +
geom_point(alpha = 0.6) +
theme_minimal() +
labs(
title = "GMM Clustering (VVI Model)",
subtitle = "Synthetic age vs. hemoglobin data",
x = "Age",
y = "Hemoglobin (g/dL)"
)
}
install.packages("car")
install.packages("psych")
shiny::runApp('Desktop/setuptwothree')
runApp('Desktop/setuptwothree')
runApp('Desktop/setupthree')
shiny::runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
# R/server/analysis_observers.R
# Helper function to perform all input and data validation
perform_validation <- function(input, data, col_value, col_age, col_gender, enable_directory, selected_dir_reactive, message_rv) {
# 1. Check if data file is uploaded and processed (data_reactive should not be NULL or empty)
if (is.null(data) || nrow(data) == 0) {
message_rv(list(type = "analysis_tab", text = "Error: No data available. Please upload and process data in the 'Data Upload & Preprocessing' tab first.", status = "error"))
return(FALSE)
}
# 2. Check if the REQUIRED Value column has been selected (these inputs are from the Data tab)
if (is.null(col_value) || col_value == "") {
message_rv(list(type = "analysis_tab", text = "Error: Please select a column for Values in the 'Data Upload & Preprocessing' tab.", status = "error"))
return(FALSE)
}
# Check if selected columns actually exist in the data_reactive (which now holds cleaned data)
required_cols <- c(col_value)
if (col_age != "") required_cols <- c(required_cols, col_age)
if (col_gender != "") required_cols <- c(required_cols, col_gender)
if (!all(required_cols %in% names(data))) {
message_rv(list(type = "analysis_tab", text = paste("Error: One or more selected columns (", paste(required_cols, collapse = ", "), ") are not found in the processed data. Please check your selections in the 'Data Upload & Preprocessing' tab.", status = "error")))
return(FALSE)
}
# 3. Directory check if auto-save is enabled but no directory is selected
if (enable_directory && is.null(selected_dir_reactive())) {
message_rv(list(type = "analysis_tab", text = "Error: Auto-save is enabled, but no directory is selected. Please select a directory.", status = "error"))
return(FALSE)
}
# If all checks pass
message_rv(list(type = "analysis_tab", text = "", status = "")) # Clear previous messages
return(TRUE)
}
# This function encapsulates the main analysis logic triggered by the analyze_btn
call_analysis_observer <- function(input, output, session, data_reactive, selected_dir_reactive) {
observeEvent(input$analyze_btn, {
# Disable button and set initial status message
shinyjs::disable("analyze_btn")
shinyjs::html("analyze_btn", "Analyzing...")
message_rv(list(type = "analysis_tab", text = "Analysis in progress... This may take a moment for multiple subpopulations.", status = "info"))
# Clear previous dynamic results
output$analysis_results_ui <- renderUI({ NULL })
# Define variables from inputs (these come from the Data tab's inputs)
col_value <- input$col_value
col_age <- input$col_age
col_gender <- input$col_gender
# --- Perform Validation ---
data_for_validation <- data_reactive() # Get the currently processed data
if (!perform_validation(input, data_for_validation, col_value, col_age, col_gender,
input$enable_directory, selected_dir_reactive, message_rv)) {
shinyjs::enable("analyze_btn")
shinyjs::html("analyze_btn", "Run Advanced Analysis")
return()
}
# Get the cleaned data from data_reactive
data <- data_for_validation
units <- input$unit_input
gender_choice <- input$gender_choice # From analysis tab
age_range <- input$age_range       # From analysis tab
nbootstrap_value <- switch(input$nbootstrap_speed,
"Fast" = 1,
"Medium" = 100,
"Slow" = 200)
# --- Prepare for Subpopulation Analysis ---
all_results_ui <- list() # To store UI elements for dynamic rendering
# Define gender mapping for filtering (moved here for scope)
gender_map <- list(
"M" = c("M", "Male", "male", "Man", "man", "Jongen", "jongen"),
"F" = c("F", "V", "Female", "female", "Woman", "woman", "Meisje", "meisje", "Vrouw", "vrouw")
)
# Determine gender groups to analyze
gender_groups_to_process <- list()
if (col_gender != "" && gender_choice %in% c("M", "F")) {
gender_groups_to_process[[gender_choice]] <- data %>% filter(tolower(!!sym(col_gender)) %in% tolower(gender_map[[gender_choice]]))
} else if (col_gender != "" && gender_choice == "Both") {
gender_groups_to_process[["Male"]] <- data %>% filter(tolower(!!sym(col_gender)) %in% tolower(gender_map[["M"]]))
gender_groups_to_process[["Female"]] <- data %>% filter(tolower(!!sym(col_gender)) %in% tolower(gender_map[["F"]]))
} else { # If no gender column selected or 'Both' but no gender column
gender_groups_to_process[["Overall"]] <- data
}
# Loop through each major gender group (or overall)
for (gender_label in names(gender_groups_to_process)) {
current_gender_data <- gender_groups_to_process[[gender_label]]
# Apply age filter if age column is selected
if (col_age != "") {
current_gender_data <- current_gender_data %>%
filter(!!sym(col_age) >= age_range[1] & !!sym(col_age) <= age_range[2])
}
# Ensure enough data for GMM after initial filtering
if (nrow(current_gender_data) < 20) { # GMM needs a decent number of points
message_rv(list(type = "analysis_tab", text = paste("Warning: Not enough data points (", nrow(current_gender_data), ") for GMM analysis in", gender_label, "group after initial filtering. Skipping subpopulation discovery for this group."), status = "warning"))
next # Skip to next gender group
}
# --- Data Preparation for GMM (Transformation and Z-scaling) ---
value_data_for_gmm <- as.numeric(na.omit(current_gender_data[[col_value]]))
age_data_for_gmm <- as.numeric(na.omit(current_gender_data[[col_age]]))
# Check for sufficient data after na.omit for GMM
if (length(value_data_for_gmm) < 20 || length(age_data_for_gmm) < 20) {
message_rv(list(type = "analysis_tab", text = paste("Warning: Not enough complete data points for GMM analysis in", gender_label, "group after NA removal. Skipping subpopulation discovery for this group."), status = "warning"))
next
}
# Conditional Yen-Johnson Transformation for value_data_for_gmm
skewness_value <- moments::skewness(value_data_for_gmm)
transformed_value_for_gmm <- value_data_for_gmm
# Apply Yeo-Johnson if skewness is significant (e.g., abs(skewness) > 1)
if (abs(skewness_value) > 1) {
tryCatch({
# Yeo-Johnson transformation using car::powerTransform
yj_transform <- powerTransform(value_data_for_gmm, family = "yj")
transformed_value_for_gmm <- predict(yj_transform, value_data_for_gmm)
message_rv(list(type = "analysis_tab", text = paste0("Applied Yeo-Johnson transformation to value data for GMM in ", gender_label, " group."), status = "info"))
}, error = function(e) {
message_rv(list(type = "analysis_tab", text = paste("Warning: Could not apply Yeo-Johnson transformation in", gender_label, "group. Using original values for GMM. Error:", e$message), status = "warning"))
})
}
# Z-scaling for GMM
scaled_value <- scale(transformed_value_for_gmm)
scaled_age <- scale(age_data_for_gmm)
# Combine for GMM input
gmm_data <- cbind(scaled_value, scaled_age)
# --- GMM Clustering for Subpopulation Discovery ---
# Only run GMM if age column is selected, otherwise treat as one subpopulation
if (col_age != "") {
tryCatch({
# Run Mclust to find optimal number of components (2 to 5) with diagonal covariance
# EII: spherical, equal volume; VII: spherical, variable volume
mclust_result <- Mclust(gmm_data, G = 2:5, modelNames = c("EII", "VII"))
cluster_assignments <- mclust_result$classification
# Add cluster assignments back to the original `current_gender_data`
# Need to map back to original rows, as gmm_data might have fewer due to NA omission
current_gender_data$cluster <- NA
current_gender_data$cluster[!is.na(current_gender_data[[col_value]]) & !is.na(current_gender_data[[col_age]])] <- cluster_assignments
message_rv(list(type = "analysis_tab", text = paste0("GMM identified ", mclust_result$G, " subpopulations for ", gender_label, " group."), status = "info"))
}, error = function(e) {
message_rv(list(type = "analysis_tab", text = paste("Warning: GMM failed for", gender_label, "group. Treating as a single subpopulation. Error:", e$message), status = "warning"))
current_gender_data$cluster <- "1" # Treat as one cluster if GMM fails
})
} else {
# If no age column selected, treat the entire gender group as one subpopulation
current_gender_data$cluster <- "1"
message_rv(list(type = "analysis_tab", text = paste("No age column selected. Treating", gender_label, "group as a single subpopulation."), status = "info"))
}
# --- Iterate through Discovered Subpopulations ---
unique_clusters <- unique(current_gender_data$cluster)
if (is.null(unique_clusters) || length(unique_clusters) == 0) {
message_rv(list(type = "analysis_tab", text = paste("Warning: No subpopulations found for", gender_label, "group. Skipping.", status = "warning")))
next
}
for (cluster_id in unique_clusters) {
subpopulation_data <- current_gender_data %>% filter(cluster == cluster_id)
# Ensure enough data for refineR::findRI
if (nrow(subpopulation_data) < 10) { # refineR needs at least 10 data points
message_rv(list(type = "analysis_tab", text = paste0("Warning: Not enough data points (", nrow(subpopulation_data), ") in ", gender_label, " Subpopulation ", cluster_id, " for RI estimation. Skipping."), status = "warning"))
next
}
subpop_numeric_data <- as.numeric(na.omit(subpopulation_data[[col_value]]))
# Determine refineR model for this subpopulation
subpop_skewness <- moments::skewness(subpop_numeric_data)
subpop_min_data <- min(subpop_numeric_data)
chosen_model <- if (subpop_min_data >= 0) { # refineR's BoxCox needs non-negative values
if (abs(subpop_skewness) <= 1) {
"BoxCox"
} else {
"modBoxCox"
}
} else {
"modBoxCox" # Use modBoxCox if data contains negative values
}
# Perform Reference Interval Estimation for subpopulation
subpop_result <- tryCatch({
refineR::findRI(Data = subpop_numeric_data, model = chosen_model, NBootstrap = nbootstrap_value, seed = 123)
}, error = function(e) {
message_rv(list(type = "analysis_tab", text = paste0("Error during RI estimation for ", gender_label, " Subpopulation ", cluster_id, ": ", e$message), status = "error"))
return(NULL)
})
if (is.null(subpop_result)) {
next # Skip to next subpopulation if RI estimation failed
}
# Generate Plot Title for Subpopulation
subpop_age_min <- floor(min(subpopulation_data[[col_age]], na.rm = TRUE))
subpop_age_max <- ceiling(max(subpopulation_data[[col_age]], na.rm = TRUE))
subpop_title_parts <- c()
if (gender_label != "Overall") {
subpop_title_parts <- c(subpop_title_parts, gender_label)
}
if (col_age != "") {
subpop_title_parts <- c(subpop_title_parts, paste0("Age ", subpop_age_min, "-", subpop_age_max))
}
subpop_title_prefix <- ifelse(length(subpop_title_parts) > 0, paste(subpop_title_parts, collapse = " "), "All Subjects")
plot_title <- sprintf("%s Subpop %s Estimated Reference Interval [%s]", subpop_title_prefix, cluster_id, units)
# Create unique IDs for dynamic outputs
plot_id <- paste0("plot_", gender_label, "_", cluster_id)
text_id <- paste0("text_", gender_label, "_", cluster_id)
# Store render functions for dynamic UI
output[[plot_id]] <- renderPlot({
plot(subpop_result, showCI = TRUE, RIperc = c(0.025, 0.975), showPathol = FALSE,
title = plot_title,
xlab = sprintf("%s [%s]", col_value, units),
ylab = "Frequency")
# Get plot limits to position text
usr <- par("usr")
y_max <- usr[4]
y_label_pos <- y_max * 0.95
# Add vertical lines and text for reference limits if provided
if (!is.na(input$ref_low)) {
abline(v = input$ref_low, col = "red", lty = 2, lwd = 2)
text(x = input$ref_low, y = y_label_pos,
labels = round(input$ref_low, 2),
col = "red", cex = 1.1, pos = 4)
}
if (!is.na(input$ref_high)) {
abline(v = input$ref_high, col = "blue", lty = 2, lwd = 2)
text(x = input$ref_high, y = y_label_pos,
labels = round(input$ref_high, 2),
col = "blue", cex = 1.1, pos = 2)
}
})
output[[text_id]] <- renderPrint({
print(subpop_result, RIperc = c(0.025, 0.975))
})
# Add UI elements to the list
all_results_ui[[length(all_results_ui) + 1]] <- div(
h3(paste0(gender_label, " Subpopulation ", cluster_id, " (Age ", subpop_age_min, "-", subpop_age_max, ")")),
plotOutput(plot_id, height = "400px"),
verbatimTextOutput(text_id),
hr() # Separator for multiple results
)
# --- Auto-Save Plot for each subpopulation ---
if (input$enable_directory) {
tryCatch({
filename <- generate_safe_filename(plot_title, selected_dir_reactive())
png(filename = filename, width = 800, height = 600)
plot(subpop_result, showCI = TRUE, RIperc = c(0.025, 0.975), showPathol = FALSE,
title = plot_title, xlab = sprintf("%s [%s]", col_value, units),
ylab = "Frequency")
usr <- par("usr")
y_max <- usr[4]
y_label_pos <- y_max * 0.95
if (!is.na(input$ref_low)) {
abline(v = input$ref_low, col = "red", lty = 2, lwd = 2)
text(x = input$ref_low, y = y_label_pos,
labels = round(input$ref_low, 2),
col = "red", cex = 1.1, pos = 4)
}
if (!is.na(input$ref_high)) {
abline(v = input$ref_high, col = "blue", lty = 2, lwd = 2)
text(x = input$ref_high, y = y_label_pos,
labels = round(input$ref_high, 2),
col = "blue", cex = 1.1, pos = 2)
}
dev.off()
print(paste("Plot saved as:", filename))
}, error = function(e) {
message_rv(list(type = "analysis_tab", text = paste("Warning: Could not save plot for", gender_label, "Subpopulation", cluster_id, ":", e$message), status = "warning"))
})
}
} # End of cluster loop
} # End of gender group loop
# Render all collected UI elements
output$analysis_results_ui <- renderUI({
do.call(tagList, all_results_ui)
})
message_rv(list(type = "analysis_tab", text = "Analysis complete! Results for all subpopulations displayed.", status = "success"))
# Re-enable analyze button and reset text
shinyjs::enable("analyze_btn")
shinyjs::html("analyze_btn", "Run Advanced Analysis")
})
# Observer for the "Reset Analysis" button in the Advanced Analysis tab
observeEvent(input$reset_btn_analysis, {
# Clear analysis-specific outputs
output$analysis_results_ui <- renderUI(NULL)
message_rv(list(type = "analysis_tab", text = "", status = "")) # Clear message for analysis tab
# Reset analysis-specific inputs
updateSelectInput(session, "gender_choice", selected = "Both")
updateSliderInput(session, "age_range", value = c(0, 100))
updateRadioButtons(session, "nbootstrap_speed", selected = "Fast")
updateNumericInput(session, "ref_low", value = NA)
updateNumericInput(session, "ref_high", value = NA)
updateTextInput(session, "unit_input", value = "mmol/L")
shinyjs::disable("select_dir_btn") # Assuming auto-save is off by default
updatePrettySwitch(session, "enable_directory", value = FALSE)
selected_dir_reactive(NULL) # Clear selected directory
showNotification("Advanced analysis settings have been reset.", type = "message")
})
}
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
install.packages("DT")
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/shorty')
runApp('Desktop/ehwty')
runApp('Desktop/ehwty')
runApp('Desktop/ehwty')
runApp('Desktop/ehwty')
runApp('Desktop/ehwty')
runApp('Desktop/ehbo')
runApp('Desktop/ehbo')
runApp('Desktop/ehbo')
runApp('Desktop/ehbo')
runApp('Desktop/ehbo')
runApp('Desktop/ehbo')
runApp('Desktop/ehbo')
runApp('Desktop/ehbo')
